package eu.benayoun.androidmoviedatabase.data.source.local.metadata.datastore

import com.google.common.truth.Truth
import eu.benayoun.androidmoviedatabase.AndroidLocalTest
import eu.benayoun.androidmoviedatabase.data.model.api.TmdbAPIError
import eu.benayoun.androidmoviedatabase.data.model.meta.TmdbMetadata
import eu.benayoun.androidmoviedatabase.data.model.meta.TmdbSourceStatus
import eu.benayoun.androidmoviedatabase.testutils.TmdbSourceStatusTester
import kotlinx.coroutines.flow.take
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.robolectric.annotation.Config

@Config(manifest= Config.NONE)
class DataStoreTmdbMetaDataCacheTest : AndroidLocalTest(){
    private lateinit var  dataStoreTmdbMetaDataCache : DataStoreTmdbMetaDataCache
    private var dataStoreFileNameNumber = 1

    @Before
    fun setup(){
        // We create a new instance of data store for each test
        // due to some error if you try to write two data
        // in the same dataStore with Robolectric (only on windows ? )
        dataStoreTmdbMetaDataCache = getDatsStoreCleanInstance()
    }

    @After
    fun tearDown(){

    }

    @Test
    fun test_save_and_retrieve_metadata_Internet() = runTest(){
        // Arrange
        val successTimestamp = 500L
        val expectedTmdbMetadata = TmdbMetadata(TmdbSourceStatus.Internet,successTimestamp)
        var actualTmdbMetadata = TmdbMetadata()

        // Act
        dataStoreTmdbMetaDataCache.saveTmdbMetaData(expectedTmdbMetadata)
        dataStoreTmdbMetaDataCache.getTmdbMetaDataFlow().take(1).collect{
            actualTmdbMetadata = it
        }

        // ASSERT
        Truth.assertThat(actualTmdbMetadata.lastInternetSuccessTimestamp).isEqualTo(expectedTmdbMetadata.lastInternetSuccessTimestamp)
        TmdbSourceStatusTester.assertEquality(actualTmdbMetadata.tmdbSourceStatus,expectedTmdbMetadata.tmdbSourceStatus)

    }

    @Test
    fun test_save_and_retrieve_metadata_Cache_NoInternet() = runTest(){
        testCacheStatus(TmdbAPIError.NoInternet)
    }

    @Test
    fun test_save_and_retrieve_metadata_Cache_NoData() = runTest(){
        testCacheStatus(TmdbAPIError.NoData)
    }

    @Test
    fun test_save_and_retrieve_metadata_Cache_Exception() = runTest(){
        testCacheStatus(TmdbAPIError.Exception("exception!"))
    }

    // There is no test_save_and_retrieve_metadata_Cache_Unknown()
    // because TmdbAPIError.Unknown is never saved, it's a value that is generated by the DataStore
    // when there is a internal problem


    private suspend fun testCacheStatus(expectedError: TmdbAPIError){
        // Arrange
        val expectedStatus = TmdbSourceStatus.Cache(expectedError)
        lateinit var actualStatus : TmdbSourceStatus

        // Act
        dataStoreTmdbMetaDataCache.saveTmdbMetaData(TmdbMetadata(expectedStatus))
        dataStoreTmdbMetaDataCache.getTmdbMetaDataFlow().take(1).collect{
            actualStatus = it.tmdbSourceStatus
        }

        // ASSERT
        TmdbSourceStatusTester.assertEquality(actualStatus,expectedStatus)
    }

    private fun getDatsStoreCleanInstance():DataStoreTmdbMetaDataCache{
        val filename = dataStoreFileNameNumber.toString()
        dataStoreFileNameNumber++
        return DataStoreTmdbMetaDataCache(
            applicationContext, filename)
    }

}